var exports=require("./aquarium.cli.min"),Game=exports.Game,Config=exports.Config,Configs=exports.Configs,Behaviours=exports.Behaviours;class Validator{constructor(behaviour_class){this.errors=[],this.behaviour_class=behaviour_class;try{this.snake=new Creatures.Snake(behaviour_class),this.behaviour=this.snake.behaviour,this.behaviour_name=Object.getPrototypeOf(this.behaviour).constructor.name}catch(er){this.errors.push("Couldn't initialize snake, this error is seen: "+er)}}check(){if(this.valid()){var validator=this;console.log("Checking "+this.behaviour_name),Object.keys(Validator.checks).forEach((function(check_name){var check=Validator.checks[check_name];try{validator.add_error_array(check(validator))}catch(error){validator.add_error("Error running check '"+check_name+"': "+error)}})),this.valid()||console.log("Errors: "+this.errors.join("\n"))}else console.log("Errors: "+this.errors.join("\n"))}add_error(error){this.errors.push(error)}add_error_array(errors){this.errors=this.errors.concat(errors)}valid(){return 0==this.errors.length}}void 0===Validator.checks&&(Validator.checks=[]),Validator.checks.class=function(validator){var errors=[];return Object.getPrototypeOf(validator.behaviour_class).name,"Behaviour"!=Object.getPrototypeOf(validator.behaviour_class).name&&errors.push("This class should extend the Behaviour class"),errors},void 0===Validator.checks&&(Validator.checks=[]),Validator.checks.colour=function(validator){var errors=[],colour=validator.behaviour.colour();if("string"==typeof colour){var parts=/rgba\(([0-9]+),([0-9]+),([0-9]+),([0-9\.]+)\)/gm.exec(colour);if(parts){var colours=[parts[1],parts[2],parts[3]];["red","green","blue"].forEach((function(colour,i){var colour_value=parseFloat(colours[i]);colour_value>255&&errors.push("colour(): "+colour+" must be between 0 and 255. It's currently "+colour_value)}));var alpha=parts[4];(alpha<.3||alpha>.5)&&errors.push("colour(): Alpha value should be between 0.3 and 0.5, currently it's "+alpha)}else errors.push("colour() function should return a valid rgba colour. Returns '"+colour+"'")}else errors.push("Behaviour should have a colour() method returning a string");return errors},void 0===Validator.checks&&(Validator.checks=[]),Validator.checks.name=function(validator){var errors=[],name=validator.behaviour.name();return"string"!=typeof name&&errors.push("Behaviour should have a name() method returning a string"),name&&name.length>30&&errors.push("Behaviour name() should not be more than 30 characters long"),errors},void 0===Validator.checks&&(Validator.checks=[]),Validator.checks.no_console_log=function(validator){var errors=[];return validator.behaviour_class.toString().includes("console.")&&errors.push("Behaviour should not make calls to the console object"),errors},void 0===Validator.checks&&(Validator.checks=[]),Validator.checks.no_food_error=function(validator){var errors=[],old_food=Game.food;Game.food=[];try{validator.behaviour.set_target(),Game.update()}catch(er){errors.push("Behaviour.set_target() throws an error when there's no food: "+er)}return Game.food=old_food,errors},void 0===Validator.checks&&(Validator.checks=[]),Validator.checks.no_game_access=function(validator){var errors=[],code=validator.behaviour_class.toString();return["Game","Config","Configs","Behaviours","Concerns","Static","Canvas"].forEach((function(forbidden){code.includes(forbidden)&&errors.push('Behaviour should not try to directly call game components. It references "'+forbidden+'"')})),errors},void 0===Validator.checks&&(Validator.checks=[]),Validator.checks.set_target=function(validator){var errors=[],set_target=validator.behaviour_class.prototype.set_target;"function"==typeof set_target?set_target.toString().includes("this.target(")||errors.push("Behaviour.set_target() should call this.target()"):errors.push("Behaviour should have a function named set_target()");return errors};module.exports = Validator
